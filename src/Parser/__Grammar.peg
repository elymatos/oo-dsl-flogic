# OO-DSL to F-Logic Grammar
# This grammar defines the syntax for our object-oriented DSL

Program
    = __ statements:(Statement __)*
    { return new ProgramNode(array_column($statements, 0), $this->location()); }

Statement
    = ClassDefinition
    / ObjectDefinition
    / MethodDefinition
    / RuleDefinition

# Class Definition
ClassDefinition
    = "class" __ name:Identifier __ inheritance:InheritanceClause? __ "{" __ body:ClassBody __ "}"
    {
        $properties = [];
        $methods = [];
        $structuralOnly = $inheritance['structural'] ?? false;
        $parent = $inheritance['parent'] ?? null;

        foreach ($body as $item) {
            if ($item instanceof PropertyNode) {
                $properties[] = $item;
            } elseif ($item instanceof MethodNode) {
                $methods[] = $item;
            }
        }

        return new ClassNode($name, $parent, $structuralOnly, $properties, $methods, $this->location());
    }

InheritanceClause
    = "inherits" __ structural:("structure" __)? "from" __ parent:Identifier
    { return ['parent' => $parent, 'structural' => $structural !== null]; }

ClassBody
    = items:(ClassBodyItem __)*
    { return array_column($items, 0); }

ClassBodyItem
    = PropertyDefinition
    / MethodSignature

# Property Definition
PropertyDefinition
    = type:TypeSpecification __ name:Identifier __ constraint:Constraint? __ ";"
    { return new PropertyNode($name, $type, $constraint, $this->location()); }

# Method Signature
MethodSignature
    = returnType:TypeSpecification __ name:Identifier __ "(" __ params:ParameterList? __ ")" __ ";"
    { return new MethodNode($name, $params ?? [], $returnType, null, true, $this->location()); }

# Object Definition
ObjectDefinition
    = "object" __ name:Identifier __ ":" __ className:Identifier __ "{" __ assignments:AssignmentList? __ "}"
    { return new ObjectNode($name, $className, $assignments ?? [], $this->location()); }

AssignmentList
    = assignments:(Assignment __)*
    { return array_column($assignments, 0); }

Assignment
    = property:Identifier __ op:AssignmentOperator __ value:Expression __ ";"
    { return new AssignmentNode($property, $op, $value, $this->location()); }

AssignmentOperator
    = "+=" / "-=" / "="

# Method Definition (Implementation)
MethodDefinition
    = "method" __ className:Identifier "." methodName:Identifier __ "(" __ params:ParameterList? __ ")" __ returnType:("returns" __ TypeSpecification)? __ body:Block
    {
        $qualifiedName = $className . '.' . $methodName;
        $retType = $returnType ? $returnType[2] : null;
        return new MethodNode($qualifiedName, $params ?? [], $retType, $body, false, $this->location());
    }

# Rule Definition
RuleDefinition
    = "rule" __ name:Identifier __ "{" __ body:RuleBody __ "}"
    { return new RuleNode($name, $body['condition'], $body['conclusion'], $this->location()); }

RuleBody
    = "if" __ "(" __ condition:Expression __ ")" __ "{" __ conclusion:Statement __ "}"
    { return ['condition' => $condition, 'conclusion' => $conclusion]; }

# Type System
TypeSpecification
    = CollectionType
    / PrimitiveType
    / CustomType

CollectionType
    = collectionType:("set" / "list") __ "<" __ elementType:TypeSpecification __ ">" __ constraint:Constraint?
    { return new TypeNode($collectionType, $elementType, $constraint, $this->location()); }

PrimitiveType
    = type:("string" / "integer" / "boolean" / "float")
    { return new TypeNode($type, null, null, $this->location()); }

CustomType
    = name:Identifier
    { return new TypeNode($name, null, null, $this->location()); }

Constraint
    = "{" __ range:Range __ "}"
    { return new ConstraintNode($range['min'], $range['max'], $this->location()); }

Range
    = min:Integer __ ".." __ max:(Integer / "*")
    { return ['min' => $min, 'max' => $max === '*' ? null : $max]; }
    / single:Integer
    { return ['min' => $single, 'max' => $single]; }

# Parameters
ParameterList
    = first:Parameter __ rest:("," __ Parameter)*
    { return [$first, ...array_column($rest, 2)]; }

Parameter
    = type:TypeSpecification __ name:Identifier
    { return new ParameterNode($name, $type, $this->location()); }

# Expressions
Expression
    = LogicalExpression

LogicalExpression
    = left:ComparisonExpression __ right:(LogicalOperator __ ComparisonExpression)*
    {
        $result = $left;
        foreach ($right as $item) {
            $result = new BinaryExpressionNode($result, $item[0], $item[2], $this->location());
        }
        return $result;
    }

LogicalOperator
    = "&&" / "||" / "and" / "or"

ComparisonExpression
    = left:AdditiveExpression __ right:(ComparisonOperator __ AdditiveExpression)?
    {
        if ($right) {
            return new BinaryExpressionNode($left, $right[0], $right[2], $this->location());
        }
        return $left;
    }

ComparisonOperator
    = "==" / "!=" / "<=" / ">=" / "<" / ">"

AdditiveExpression
    = left:MultiplicativeExpression __ right:(AdditiveOperator __ MultiplicativeExpression)*
    {
        $result = $left;
        foreach ($right as $item) {
            $result = new BinaryExpressionNode($result, $item[0], $item[2], $this->location());
        }
        return $result;
    }

AdditiveOperator
    = "+" / "-"

MultiplicativeExpression
    = left:UnaryExpression __ right:(MultiplicativeOperator __ UnaryExpression)*
    {
        $result = $left;
        foreach ($right as $item) {
            $result = new BinaryExpressionNode($result, $item[0], $item[2], $this->location());
        }
        return $result;
    }

MultiplicativeOperator
    = "*" / "/" / "%"

UnaryExpression
    = operator:UnaryOperator __ operand:PrimaryExpression
    { return new UnaryExpressionNode($operator, $operand, $this->location()); }
    / PrimaryExpression

UnaryOperator
    = "!" / "not" / "-"

PrimaryExpression
    = "(" __ expr:Expression __ ")"
    { return $expr; }
    / MethodCall
    / PropertyAccess
    / SetLiteral
    / Literal
    / "this"
    { return new IdentifierNode('this', $this->location()); }
    / Identifier
    { return new IdentifierNode($1, $this->location()); }

MethodCall
    = object:Identifier __ "." __ method:Identifier __ "(" __ args:ArgumentList? __ ")"
    {
        $objectNode = new IdentifierNode($object, $this->location());
        return new MethodCallNode($objectNode, $method, $args ?? [], $this->location());
    }

PropertyAccess
    = object:Identifier __ "." __ property:Identifier
    {
        $objectNode = new IdentifierNode($object, $this->location());
        return new PropertyAccessNode($objectNode, $property, $this->location());
    }

ArgumentList
    = first:Expression __ rest:("," __ Expression)*
    { return [$first, ...array_column($rest, 2)]; }

SetLiteral
    = "{" __ elements:ElementList? __ "}"
    { return new SetLiteralNode($elements ?? [], $this->location()); }

ElementList
    = first:Expression __ rest:("," __ Expression)*
    { return [$first, ...array_column($rest, 2)]; }

Block
    = "{" __ statements:(Statement __)* __ "}"
    { return new BlockNode(array_column($statements, 0), $this->location()); }

# Literals
Literal
    = String
    / Float
    / Integer
    / Boolean

String
    = '"' chars:StringChar* '"'
    { return new LiteralNode(implode('', $chars), 'string', $this->location()); }

StringChar
    = '\\"' { return '"'; }
    / '\\\\' { return '\\'; }
    / [^"]

Float
    = digits:[0-9]+ "." decimals:[0-9]+
    { return new LiteralNode(floatval(implode('', $digits) . '.' . implode('', $decimals)), 'float', $this->location()); }

Integer
    = digits:[0-9]+
    { return new LiteralNode(intval(implode('', $digits)), 'integer', $this->location()); }

Boolean
    = "true" { return new LiteralNode(true, 'boolean', $this->location()); }
    / "false" { return new LiteralNode(false, 'boolean', $this->location()); }

# Identifier
Identifier
    = [a-zA-Z_][a-zA-Z0-9_]*
    { return $this->text(); }

# Whitespace and Comments
__
    = (Whitespace / Comment)*

Whitespace
    = [ \t\n\r]+

Comment
    = "//" [^\n\r]*
    / "/*" (!"*/" .)* "*/"